<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-repeat.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-if.html">
<link rel="import" href="boardgame-card.html">

<dom-module id="boardgame-component-stack">
  <template>
    <style>

      :host {
        width:100%;
      }

      #container {
        position: relative;
        @apply --layout-horizontal;
        @apply --layout-center;
      }

      #container #slot-holder {
        @apply --layout-horizontal;
        @apply --layout-center;
      }

      #animating-components [boardgame-component] {
        /* don't mess with the general layout because the card will be gone soon */
        position: absolute;
      }

      #container ::slotted([boardgame-component]), #container [boardgame-component] {
        transition: transform var(--animation-length, 0.25s) ease-in-out, opacity var(--animation-length, 0.25s) ease-in-out;
      }

      #container.no-animate ::slotted([boardgame-component]), #container.no-animate [boardgame-component] {
        transition: unset;
      }

      #container.grid #slot-holder, #container.stack #slot-holder {
         @apply --layout-wrap;
      }

      #container ::slotted([boardgame-component]), #container [boardgame-component] {
        margin: 1em;
      }

      .pile ::slotted([boardgame-component]):first-child, .pile [boardgame-component]:first-child {
        position:relative;
      }

      .pile ::slotted([boardgame-component]), .pile [boardgame-component] {
        position:absolute;
      }

      /* most cards in stacks should be at the front, and a few pixels down so
      /* you can see them behind the first few cards */

      .stack ::slotted([boardgame-component]), .stack [boardgame-component] {
        position: absolute;
        top: 6px;
        left: 0px;
      }

      /* the first child should actually take up layout space for the entire
      /* stack, and not be offset any. */

      .stack ::slotted([boardgame-component]:first-child), .stack [boardgame-component]:first-child, .stack [boardgame-component]#spacer {
        z-index: 10;
        position: relative;
        top:0px;
      }

      /* The second card should stick out justa bit */

      .stack ::slotted([boardgame-component]:nth-child(2)), .stack [boardgame-component]:nth-child(2) {
        top:2px;
        z-index: 9;
      }

      /* The third card should stick out just a bit more */

      .stack ::slotted([boardgame-component]:nth-child(3)), .stack [boardgame-component]:nth-child(3) {
        z-index: 8;
        top:4px;
      }

      #container.spread #slot-holder {
        
        /* If we just applied layout-around-justified to #container.spread, it
        /* wouldn't work because the children are actually the four containers */
        @apply --layout-horizontal;
        @apply --layout-around-justified;
        width:100%;
      }

      #container.spread #slot-holder ::slotted(dom-repeat) {
        /* If we don't do this then oddly enough the dom-repeats will take up space in the layout! */
        display: none;
      }

      .spread ::slotted([boardgame-component]:hover), .spread [boardgame-component]:hover, .fan ::slotted([boardgame-component]:hover), .fan [boardgame-component]:hover {
        z-index:1;
      }

      #container.spread ::slotted([boardgame-component]), #container.spread [boardgame-component] {
        /* default card width */
        margin-right: calc(100px * -0.75);
      }

      #container.spread ::slotted([boardgame-component].bcc-last), #container.spread [boardgame-component].bcc-last {
        margin-right: 0;
      }

      #container.fan ::slotted([boardgame-component]), #container.fan [boardgame-component] {
        /* default card width */
        margin-right: calc(100px * -0.5);
      }

      #container.fan ::slotted([boardgame-component][rotated]), #container.fan [boardgame-component][rotated] {
        /* default card width */
        margin-right: calc(100px * -0.25);
      }

      #container.fan ::slotted([boardgame-component].bcc-last), #container.fan [boardgame-component].bcc-last {
        margin-right: 0;
      }

      #container.fan {
        /* give a bit more vertical breathing room for the arc */
        box-sizing:border-box;
        padding: 1em 0;
      }

    </style>

    <div id="container" class$="{{_classes(layout, noAnimate)}}">
      <div id="slot-holder">
        <slot id="components"></slot>
      </div>
      <!-- spacer will be created here if necessary --> 
      <div id="faux-components">
        <!--Faux components will go here -->
      </div>
      <div id="animating-components"></div>
    </div>
  </template>

  <script>

    var BoardgameComponentStack;

    (function(){ 

      var sharedStackList = [];
      //Anytime that we see that a given stack has a given component type we
      //remember it for future componentType gets.
      var deckComponentType = {};

      BoardgameComponentStack = class extends Polymer.Element {

        static get is() {
          return "boardgame-component-stack"
        }

        static get properties() {
          return {
            //layout sets the layout style to use. One of `stack` (default),
            //`grid`, `spread`, `fan` and `pile`
            layout: {
              type: String,
              observer: "_updateComponentClasses",
              value: "stack"
            },
            //stack should be set to the state value corresponding to a stack.
            //It will set idsLastSeen, and also set the first dom-repeat it
            //finds as a child's items to stack.Components.
            stack : {
              type: Object,
              value: null,
              observer: "_stackChanged"
            },
            //If set, this stack will be combined with the secondary stack and 
            //the result will be set to stack.
            primaryStack: {
              type: Object,
              value: null
            },
            secondaryStack: {
              type: Object,
              value: null
            },
            //may be `overlap` (default) or `concatenate`
            stackCombine: {
              type: String,
              value: "overlap"
            },
            //if true, all cards will have a slight rotation transformation
            //applied to make the layout not look artificially tidy
            messy: {
              type: Boolean,
              value: false,
              observer: "_updateComponentClasses"
            },
            //If the cards are messy, how messy are they? 1.0 is default
            //messiness, 2.0 is twice as messy.
            messiness: {
              type: Number,
              value: 1.0,
              observer: "_updateComponentClasses"
            },
            //idsLastSeen should be the IdsLastSeen for the stack that this
            //stack represents. boardgame-component-animator will use this
            //value to figure out where to animate from and to.
            idsLastSeen: Object,
            //if true, animations will be suppressed
            noAnimate: Boolean,
            //If there are no cards, by default we'll inject a single spacer
            //(invisibled) card, just to make sure the overall layout doesn't
            //jump when a card is added to this stack. If this property is
            //true, we won't do that.
            noDefaultSpacer: Boolean,
            //If there aren't more than fauxCards "real" cards in the stack,
            //we'll make fake cards until there are this many cards. This is
            //useful if you have, for example, a very big draw deck and only
            //want to actually render the first few cards.
            fauxComponents: {
              type: Number,
              value: 0
            },
            //Overrides componentType() if the auto-set characteristics aren't
            //sufficient.
            manualComponentType: String,

            _randomRotationOffset: {
              type: Number,
              value: 0
            },
          }
        }

        static get observers() {
          return [
            '_updateDerivedStack(primaryStack, secondaryStack, stackCombine)'
          ]
        }

        get _sharedStackList() {
          return sharedStackList;
        }

        //type is the type of component that we contain. It is set based on
        //manualComponenType, then the type of any components we've last seen,
        //then defaults to "card".
        get componentType() {

          if (this.stack) {
            if (deckComponentType[this.stack.Deck]) {
              return deckComponentType[this.stack.Deck]
            }
          }

          let result = this.manualComponentType;

          if (!result) {
            let components = this._realComponents;
            if (components.length && components.length > 0) {
              let component = components[0];
              result = component.localName.replace("boardgame-", "");
            }
          }

          if (result) {
            if (this.stack) {
              deckComponentType[this.stack.Deck] = result;
            }

            return result;
          }

          //Whatever, just return "card", I guess...
          return "card";
        }

        //Returns a new component for this stack set reasonably, based on
        //componentType and autoSetType.
        newComponent() {
          let ele = document.createElement("boardgame-" + this.componentType);

          for (let propName of ele.configProperties) {
            ele[propName] = this.stackDefault(propName);
          }
          
          return ele;
        }

        //stackDefault goes through the entire stack, and returns the most
        //popular value for propName, skipping elements that don't have it.
        stackDefault(propName) {
          //Just default to setting whatever the most common type is in the
          //stack.
          let propCount = {};
          let maxCount = 0;
          let maxVal = false;
          for (let c of this.Components) {
            let val = c[propName]
            if (val === undefined) {
              continue;
            }
            propCount[val] = (propCount[val] || 0) + 1
            if (propCount[val] > maxCount) {
              maxCount = propCount[val];
              maxVal = val;
            }
          }
          return maxVal;
        }

        connectedCallback() {
          sharedStackList.push(this);
        }

        disconnectedCallback() {
          var i = 0;
          while (i < sharedStackList.length) {
            var item = sharedStackList[i];
            if (i == this) {
              sharedStackList.splice(i, 1);
            } else {
              i++;
            }
          }
        }

        //offsetCard returns a card in the stack to use for positioning.
        get offsetComponent() {
          var components = this._realComponents;
          if (components.length > 0) return components[0];
          var component = this.shadowRoot.querySelector("[boardgame-component]");
          if (component) return component;
          return this;
        }

        //id will be set to a long, stable Id for this stack during its
        //lifetime. Primarily useful to identify itself to the animation-
        //coordinator.
        get id() {
          return this._id;
        }

        ready() {
          super.ready();
          this.$.components.addEventListener("slotchange", () => this._slotChanged(false));
          //If the children are already stamped, update now.
          this._slotChanged(true);
          //Generate a random rotation offset from 0 to 20 that will make this
          //stack have rotatons that are stable as long as the stack exists
          //(which it will in general because Polymer databinding will reuse
          //elements) but different from most other stacks.
          this._randomRotationOffset = Math.floor(Math.random() * 21);
          this._randomOffsetRotationOffset = Math.floor(Math.random() * 101);
          this._randomOffsetRotationOffsetY = Math.floor(Math.random() * 101);
          this._id = this._randomId(8);
        }

        //setUnknownAnimationState sets the "final" state of the styling on a
        //card that is flying to the unknown state. Used by boardgame-
        //component-animator.
        setUnknownAnimationState(card) {
          card.style.transform = "scale(0.6)";
          card.style.opacity = "0.0";
        }

        //Returns a new card to animate its position. When its transition ends it will be removed.
        newAnimatingComponent() {
          var component = this.newComponent();
          component.noAnimate = true;
          component.prepareForBeingAnimatingComponent(this);
          this.setUnknownAnimationState(component);
          this.$["animating-components"].appendChild(component);
          component.addEventListener("transitionend", e => this._clearAnimatingComponents(e));
          return component;
        }

        _clearAnimatingComponents(e) {
          var container = this.$['animating-components'];
          while(container.children.length > 0) {
            var child = container.children[0];
            container.removeChild(child);
          }
        }

        _stackChanged(newValue) {
          if (!newValue) return;
          this.idsLastSeen = newValue.IdsLastSeen || {};
          var repeater = this.querySelector("dom-repeat");
          if (!repeater) {
            console.warn("Couldn't find a repeater to stamp stack items into")
            return;
          }
          repeater.items = newValue.Components;
        }

        _updateDerivedStack(primaryStack, secondaryStack, stackCombine) {
          if (!primaryStack && !secondaryStack) return;
          if (primaryStack && !secondaryStack) {
            this.stack = primaryStack;
            return;
          }
          if (secondaryStack && !primaryStack) {
            this.stack = secondaryStack;
            return;
          }

          //If we get to here we have values for both stacks.

          if (primaryStack.Deck != secondaryStack.Deck) {
            console.warn("Primary and Secondary stacks are of different decks, which is not allowed")
            return;
          }

          if (!this._sanityCheckStack(primaryStack)) {
            console.warn("Primary stack didn't sanity check")
            return;
          }

          if (!this._sanityCheckStack(secondaryStack)) {
            console.warn("Secondary stack didn't sanity check")
            return;
          }

          var result = this._copyObj(primaryStack);

          if (stackCombine == "concatenate") {
            for (var i = 0; i < secondaryStack.Components.length; i++) {
              result.Components.push(secondaryStack.Components[i]);
              result.Ids.push(secondaryStack.Ids[i]);
              result.Indexes.push(secondaryStack.Indexes[i]);
            }
          } else {
            //Default to "overlap"
            if (primaryStack.Components.length != secondaryStack.Components.length) {
              console.warn("Overlap combination but stacks were not equal length")
              return;
            }
            for (var i = 0; i < primaryStack.Components.length; i++) {
              if (result.Components[i]) {
                //If the primary already has an item, no need to fill in from secondary.
                continue;
              }
              result.Components[i] = secondaryStack.Components[i];
              result.Ids[i] = secondaryStack.Ids[i];
              result.Indexes[i] = secondaryStack.Indexes[i];
            }
          }

          //Go through each id in IdsLastSeen, if it's already in the result's
          //map, then overwrite only if index is greater.

          for (let attr in secondaryStack.IdsLastSeen) {
            if (!secondaryStack.IdsLastSeen.hasOwnProperty(attr)) continue;
            if (result.IdsLastSeen[attr]) {
              //If that id was already in the result, only overwrite if our version is higher.
              if (result.IdsLastSeen[attr] < secondaryStack.IdsLastSeen[attr]) {
                result.IdsLastSeen[attr] = secondaryStack.IdsLastSeen[attr];
              }
            } else {
              result.IdsLastSeen[attr] = secondaryStack.IdsLastSeen[attr];
            }
          }

          this.stack = result;

        }

        _sanityCheckStack(stack) {

          if (!stack) return false;

          if (!stack.Components || !stack.Ids || !stack.Indexes || !stack.IdsLastSeen) {
            return false;
          }

          if (stack.Components.length != stack.Ids.length) return false;
          if (stack.Components.length != stack.Indexes.length) return false;

          return true;
        }

        get _realComponents() {
          var components = this.$.components.assignedNodes();

          var result = [];

          for (var i = 0; i < components.length; i++) {
            var component = components[i];

            if (!component.localName || component.getAttribute("boardgame-component") !== "") {
              //Skip text nodes and nodes that aren't cards
              continue;
            }

            result.push(component);
          }

          return result;
        }

        get _fauxComponents() {
          var fauxComponents = this.$['faux-components'].querySelectorAll("[boardgame-component]");

          return [...fauxComponents];
        }

        get Components() {
          return this._realComponents.concat(this._fauxComponents);
        }

        _slotChanged(firstRender) {

          var realComponents = this._realComponents;

          if (firstRender && realComponents.length < 1 ) return;

          let fauxComponentsContainer = this.$["faux-components"];

          if (realComponents.length < this.fauxComponents) {

            let targetNumFauxComponents = this.fauxComponents - realComponents.length;

            let starterComponentIndex = fauxComponentsContainer.children.length

            let childrenToAdd =  targetNumFauxComponents - starterComponentIndex;
          
            if (childrenToAdd > 0) {
              for (let i = 0; i < childrenToAdd; i++) {
                let fauxComponent = this.newComponent();
                fauxComponent.index = starterComponentIndex + i;
                fauxComponentsContainer.appendChild(fauxComponent);
              }
            } else if (childrenToAdd < 0) {
              //We have childrent to remove
              for (let i = 0; i > childrenToAdd; i--) {
                fauxComponentsContainer.removeChild(fauxComponentsContainer.children[0]);
              }
            }

          }

          let wantSpacer = realComponents.length < 1 && !this.noDefaultSpacer;

          let haveSpacer = !!this.shadowRoot.querySelector("#container>[boardgame-component][spacer]")

          //Add a spacer if we need one.
          if (wantSpacer && !haveSpacer) {
            //Need to add one.
            let spacer = this.newComponent();
            spacer.spacer = true;
            spacer.id = "spacer";
            this.$.container.insertBefore(spacer, fauxComponentsContainer);
          }

          //Trim down any extra spacers. It's possible for too many to be
          //added in weird race conditions.
          let targetNumSpacers = wantSpacer ? 1 : 0;

          let spacers = this.shadowRoot.querySelectorAll("#container>[boardgame-component][spacer]")

          while (spacers.length > targetNumSpacers) {
            this.$.container.removeChild(spacers[0]);
            spacers = this.shadowRoot.querySelectorAll("#container>[boardgame-component][spacer]")
          }

          this._updateComponentClasses();

        }

        _updateComponentClasses() {

          //Called when layout changes, or when items are added or removed from
          //the slot.

          //TODO: the fact that we do this imperatively (and trample on whatever
          //shadow setting was explicilty set by the element to start) seems
          //like a smell. However, doing this just with CSS was quite hard.

          var components = this.Components;

          for (var i = 0; i < components.length; i++) {
            var component = components[i];

            var classes = ["bcc-last"];

            for (var j = 0; j < classes.length; j++) {
              component.classList.remove(classes[j]);
            }

            let transformPieces = [];

            if (this.messy) {
              transformPieces.push("rotate(" + this._messyRotationForIndex(i) + "deg)");
            }

            if (this.layout == "pile") {
              let pieceToPush = "translate(" + this._randomOffsetForIndex(i, true) + "px, " + this._randomOffsetForIndex(i, false) + "px)"
              transformPieces.push(pieceToPush);
            }

            //We always set transform even if it's "" because _fanCards
            //assumes that transform has been reset in this layout pass.
            component.style.transform = transformPieces.join(" ");

            if (i == components.length - 1) {
              component.classList.add("bcc-last");
            }

            if (this.layout != "stack") {
              component.noShadow = false;
              continue
            }

            if (i < 4) {
              component.noShadow = false;
            } else {
              component.noShadow = true;
            }
          }

          if (this.layout == "fan") {
            this._fanComponents();
          }

        }

        _fanComponents() {
          var components = this.Components;

          //TODO: set the amount of max rotation based on length of stack;
          var maxRotation = 20;
          var minRotation = maxRotation * -1;
          
          var maxTranslate = -1.0;
          var minTranslate = 1.5;

          //stackDefault will just return false if the items in the stack
          //don't have a rotated property.
          let rotated = this.stackDefault("rotated");
          
          if (components.length < 8 && rotated || !rotated && components.length < 3) {
            var percent = 0.5
            maxRotation *= percent;
            minRotation *= percent;
            maxTranslate *= percent;
            minTranslate *= percent;
          }

          var rotationSpread = maxRotation - minRotation;
          var translateSpread = maxTranslate - minTranslate;


          for (var i = 0; i < components.length; i++) {
              var component = components[i];

              var percent = (i / (components.length - 1));

              var rotation = percent * rotationSpread + minRotation;

              //TODO: preserve the messiness transformations
              var rotationTransformation = "rotate(" + rotation + "deg)";

              var translateRadians = 3.0 * percent - 1.5;

              if (percent < 0) {
                translateRadians = translateRadians * -1;
              }

              var translate = Math.cos(translateRadians) * translateSpread + minTranslate;

              var translateTransformation = "translateY(" + translate + "em)";

              component.style.transform += rotationTransformation + " " + translateTransformation;

          }

        }

        _messyRotationForIndex(index) {

          var values = [-0.6, 1.6, -2.8, 2.4, -1.6, 3.0, -0.6, -2.4, -3.6, 1.4, -1.8, 1.8, 0.2, 3.6, 1.4, -1.0];

          index = (index  + this._randomRotationOffset) % values.length;

          let messiness = this.messiness;

          if (this.layout == "pile") messiness *= 4;

          return values[index] * messiness;

        }

        _randomOffsetForIndex(index, x) {
          let values = [0.57, 0.67, 0.93, -0.21, -0.76, 0.83, 0.97, 0.49, 0.75, 0.14, 0.21, -0.25, -0.84, 0.09, 0.78, 0.56, -0.77, 0.02, -0.07, 0.2, 0.78, 0.31, -0.49, -0.96, 0.46, -0.51, 0.26, -0.47, -0.14, 0.99, 0.36, -0.16, 0.77, 0.21, 0.19, -0.46, -0.69, 0.44, 0.31, -0.18, -0.57, 0.97, 0.44, -0.57, -0.66, -0.14, -0.15, -0.33, -0.05, -0.94, 0.84, -0.8, -0.73, -0.56, 0.33, 0.04, -0.01, 0.68, 0.9, 0.55, -0.43, -0.67, 0.41, 0.51, 0.16, -0.35, 0.98, -0.84, -0.28, 0.43, 0.11, -0.97, 0.92, 0.51, -0.3, -0.22, -0.13, 0.82, 0.33, 0.77, 0.1, -0.74, -0.26, -0.09, 0.69, -0.51, 0.79, -0.37, 0.88, -0.21, -0.07, 0.02, -0.93, -0.03, 0.76, 0.91, 0.58, 0.4, 0.96, 0.89];

          let randomOffsetToUse = x ? this._randomOffsetRotationOffset : this._randomOffsetRotationOffsetY;

          index = (index + randomOffsetToUse) % values.length;

          //TODO: make this a constant
          return values[index] * 30;
        }

        _classes(layout, noAnimate) {
          var result = [];
          if (layout) {
            result.push(layout);
          }
          if (noAnimate) {
            result.push("no-animate");
          }
          return result.join(" ");
        }

        _copyObj(obj) {
          let copy = {}
          for (let attr in obj) {
            if (obj.hasOwnProperty(attr)) copy[attr] = obj[attr]
          }
          return copy
        }

        _randomId(length) {
            var text = "";
            var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

            for( var i=0; i < length; i++ ) {
              text += possible.charAt(Math.floor(Math.random() * possible.length));
            }

            return text;
        }
      } 

    })();

    customElements.define(BoardgameComponentStack.is, BoardgameComponentStack);
  </script>
</dom-module>
