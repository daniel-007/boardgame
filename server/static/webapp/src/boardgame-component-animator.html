<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="boardgame-card-collection.html">

<dom-module id="boardgame-component-animator">
  <template>
    <boardgame-card-collection id='collection' no-default-spacer></boardgame-card-collection>
  </template>

  <script>

    class BoardgameComponentAnimator extends Polymer.Element {
      static get is() {
        return "boardgame-component-animator"
      }

      static get properties() {
        return {
          _infoById: Object,
          ancestorOffsetParent: Object
        }
      }

      _calculateOffsets(ele) {
        var top = 0;
        var left = 0;

        var offsetEle = ele;
        while (offsetEle) {

          top += offsetEle.offsetTop;
          left += offsetEle.offsetLeft;

          if (offsetEle == this.ancestorOffsetParent) {
            offsetEle = null;
          } else {
            offsetEle = offsetEle.offsetParent;
          }
        }

        return {
          top: top,
          left: left
        };
      }

      prepare() {

        var collections = this.$.collection._sharedCollectionList;

        var result = {};

        for (var i = 0; i < collections.length; i++) {
          var collection = collections[i];
          var cards = collection.Cards;
          for (var j = 0; j < cards.length; j++) {
            var card = cards[j];
            var record = {};

            record.offsets = this._calculateOffsets(card);
            record.previousTransform = card.style.transform;

            record.faceUp = card.faceUp;

            record.clonedNodes = [];

            if (!card.oldFront) {
              //If the card has old-front, that's a signal that content is bad
              //and not worth copying.
              var children = card.children;
              for (var k = 0; k < children.length; k++) {
                var child = children[k];
                if (child.slot) {
                  //Skip content that doesn't go in default slot
                  continue
                }
                record.clonedNodes.push(child.cloneNode(true));
              }
            }

            //TODO: record the innerHTML
            result[card.id] = record;
          }
        }

        this._infoById = result;
      }

      animate() {
        window.requestAnimationFrame(()=> this._doAnimate());
      }

      _doAnimate() {
        var collections = this.$.collection._sharedCollectionList;

        for (var i = 0; i < collections.length; i++) {

          var collection = collections[i];
          collection.noAnimate = true;
          var cards = collection.Cards;
          for (var j = 0; j < cards.length; j++) {
            var card = cards[j];
            var record = this._infoById[card.id];

            if (!record) continue;

            record.postPreviousTransform = card.style.transform;
            record.newOffsets = this._calculateOffsets(card);


            //TODO: if calculating offsetTop,Left is expensive here, split all
            //reads into a separate pass before this

            var invertTop = record.offsets.top - record.newOffsets.top;
            var invertLeft = record.offsets.left - record.newOffsets.left;

            if (invertTop != 0 || invertLeft != 0) {
              var transform = `translateY(${invertTop}px) translateX(${invertLeft}px)`
              card.style.transform = transform + " " + record.previousTransform;
            }
            
          }
        }

        //Do a second pass because this will affect layout
        for (var i = 0; i < collections.length; i++) {
          var collection = collections[i]; 
          for (var j = 0; j < cards.length; j++) {
            var card = cards[j];
            var record = this._infoById[card.id];

            if (!record) continue;

            if (record.clonedNodes.length > 0) {

              //Clear out old nodes.
              for (var k = 0; k < card.children.length; k++) {
                var child = card.children[k];
                if (child.slot == "old") {
                  card.removeChild(child);
                }
              }
              for (var k = 0; k < record.clonedNodes.length; k++) {
                var node = record.clonedNodes[k];
                node.slot = "old";
                card.appendChild(node);
              }
            }
          }
        }

        //Wait for styles to be set to do the animations
        window.requestAnimationFrame(() => this._startAnimations());

      }

      _startAnimations() {
        var collections = this.$.collection._sharedCollectionList;

        for (var i = 0; i < collections.length; i++) {
          var collection = collections[i];
          collection.noAnimate = false;
          var cards = collection.Cards;
          for (var j = 0; j < cards.length; j++) {
            var card = cards[j];
            var record = this._infoById[card.id];
            if (!record) continue;
            card.style.transform = record.postPreviousTransform;
          }
        }
      }

    }

    customElements.define(BoardgameComponentAnimator.is, BoardgameComponentAnimator);

  </script>
</dom-module>
