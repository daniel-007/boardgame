<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="boardgame-card-stack.html">

<dom-module id="boardgame-component-animator">
  <template>
    <boardgame-card-stack id='stack' no-default-spacer></boardgame-card-stack>
  </template>

  <script>

    class BoardgameComponentAnimator extends Polymer.Element {
      static get is() {
        return "boardgame-component-animator"
      }

      static get properties() {
        return {
          _infoById: Object,
          _beforeSeenIds: Object,
          _animatingCards: Array,
          ancestorOffsetParent: Object
        }
      }

      _calculateOffsets(ele) {
        var top = 0;
        var left = 0;
        var width = 0;
        var height = 0;

        var offsetEle = ele;
        while (offsetEle) {

          top += offsetEle.offsetTop;
          left += offsetEle.offsetLeft;
          width += offsetEle.offsetWidth;
          height += offsetEle.offsetHeight;

          if (offsetEle == this.ancestorOffsetParent) {
            offsetEle = null;
          } else {
            offsetEle = offsetEle.offsetParent;
          }
        }

        return {
          top: top,
          left: left,
          width: width,
          height: height
        };
      }

      prepare() {

        var collections = this.$.stack._sharedStackList;

        var result = this._infoById || {};

        //keep track of all of the ids we've seen this round to make sure we
        //found a home for all of them in the end.
        this._beforeSeenIds = new Set();

        for (var i = 0; i < collections.length; i++) {
          var collection = collections[i];
          var cards = collection.Cards;
          for (var j = 0; j < cards.length; j++) {
            var card = cards[j];
            var record = result[card.id] || {};

            this._beforeSeenIds.add(card.id);

            record.offsets = this._calculateOffsets(card);

            //We use getComputedStyle instead of just card.style.transform,
            //because if the card is in the middle of transforming, we want
            //the exact value at that second, not what the logical final value
            //is.
            record.previousTransform = getComputedStyle(card).transform;

            record.beforeFaceUp = card.faceUp;

            if (!card.noContent) {
              var newNodes = [];
              //If the card has old-front, that's a signal that content is bad
              //and not worth copying.
              var children = card.children;
              for (var k = 0; k < children.length; k++) {
                var child = children[k];
                if (child.slot) {
                  //Skip content that doesn't go in default slot
                  continue
                }
                newNodes.push(child.cloneNode(true));
              }
              if (newNodes.length > 0) {
                record.clonedNodes = newNodes;
              }
            }
            result[card.id] = record;
          }
        }

        this._infoById = result;
      }

      animate() {
        window.requestAnimationFrame(()=> this._doAnimate());
      }

      _doAnimate() {
        var collections = this.$.stack._sharedStackList;

        //Sizing information of a collection
        var collectionLocations = {};
        //The last seen location of a given card ID
        var idToPossibleCollection = new Map();

        //Turning off animations and setting card flip all require recalcing
        //style so do them once before readback in the second loop.

        for (var i = 0; i < collections.length; i++) {
          var collection = collections[i];
          collection.noAnimate = true;
          var cards = collection.Cards;
          for (var j = 0; j < cards.length; j++) {
            var card = cards[j];
            card.noAnimate = true; 
          }
        }

        //This layout readback is the most important thing to do quickly
        //because if we thrash the DOM there will be a lot of recalc style. So
        //do it in its own pass.
        for (var i = 0; i < collections.length; i++) {
          var collection = collections[i];

          //Keep track of offsets of collection in case we need to animate a
          //card to it generically
          collectionLocations[collection.id] = this._calculateOffsets(collection);

          var cards = collection.Cards;
          for (var j = 0; j < cards.length; j++) {
            var card = cards[j];
            var record = this._infoById[card.id];

            if (!record) continue;
            record.newOffsets = this._calculateOffsets(card);        
          }
        }

        //This is the meat of the method, where we set all layout-affecting
        //properties, append fake dom, etc.
        for (var i = 0; i < collections.length; i++) {

          var collection = collections[i];

          //Note which Ids were last seen here
          this._ingestStack(idToPossibleCollection, collection);

          var cards = collection.Cards;
          for (var j = 0; j < cards.length; j++) {
            var card = cards[j];
            var record = this._infoById[card.id];

            if (!record) continue;

            //Mark that we've seen where this one is going.
            this._beforeSeenIds.delete(card.id);

            record.postPreviousTransform = card.style.transform;

            record.afterFaceUp = card.faceUp;
            card.faceUp = record.beforeFaceUp;       

            //TODO: if calculating offsetTop,Left is expensive here, split all
            //reads into a separate pass before this

            var invertTop = record.offsets.top - record.newOffsets.top;
            var invertLeft = record.offsets.left - record.newOffsets.left;

            //We used to only bother setting transforms for items that had
            //physically moved. However, the browser is smart enough to ignore
            //transforms that are basically no ops. And if we don't set it
            //then cards that don't physically move but do have transform
            //changes won't animate because the transform was set during
            //noAnimate and is never set to anything different. In testing
            //this didn't appear to have any appreciable performance difference.
            var transform = `translateY(${invertTop}px) translateX(${invertLeft}px)`
            card.style.transform = transform + " " + record.previousTransform;

            if (record.clonedNodes && record.clonedNodes.length > 0) {

              //Clear out old nodes.
              for (var k = 0; k < card.children.length; k++) {
                var child = card.children[k];
                if (child.slot == "fallback") {
                  card.removeChild(child);
                }
              }
              for (var k = 0; k < record.clonedNodes.length; k++) {
                var node = record.clonedNodes[k];
                node.slot = "fallback";
                card.appendChild(node);
              }
            }
            
          }
        }


        this._animatingCards = [];

        //Any items still in _beforeSeenIds did not have a specific card to
        //animate to. Let's see if we can figure out which collection they
        //went to.
        for (let id of this._beforeSeenIds) {

          //Which stack do we think this is in now?
          var record = idToPossibleCollection.get(id);

          if (!record) {
            //Guess it's a mystery. :-(
            continue;
          }

          var card = record.stack.newAnimatingCard();

          this._animatingCards.push({
            card: card,
            previousTransform: card.style.transform
          })

          var stackLocation = collectionLocations[record.stack.id];
          var oldLocation = this._infoById[id].offsets;

          var invertTop = oldLocation.top - stackLocation.top;
          var invertLeft = oldLocation.left - stackLocation.left;

          //We used to only bother setting transforms for items that had
          //physically moved. However, the browser is smart enough to ignore
          //transforms that are basically no ops. And if we don't set it
          //then cards that don't physically move but do have transform
          //changes won't animate because the transform was set during
          //noAnimate and is never set to anything different. In testing
          //this didn't appear to have any appreciable performance difference.
          var transform = `translateY(${invertTop}px) translateX(${invertLeft}px)`
          card.style.transform = transform;
        }

        //Wait for styles to be set to do the animations
        window.requestAnimationFrame(() => this._startAnimations());

      }

      _startAnimations() {
        var collections = this.$.stack._sharedStackList;

        for (var i = 0; i < collections.length; i++) {
          var collection = collections[i];
          collection.noAnimate = false;
          var cards = collection.Cards;
          for (var j = 0; j < cards.length; j++) {
            var card = cards[j];
            var record = this._infoById[card.id];
            if (!record) continue;
            card.noAnimate = false;
            card.style.transform = record.postPreviousTransform;
            card.faceUp = record.afterFaceUp;

          }
        }

        for (var i = 0; i < this._animatingCards.length; i++) {
          var record = this._animatingCards[i];
          record.card.style.transform = record.previousTransform;
        }

      }

      _ingestStack(possibleLocations, stack) {

        var idsLastSeen = stack.idsLastSeen;

        for (var key in idsLastSeen) {
          if (!idsLastSeen.hasOwnProperty(key)) continue;

          if (possibleLocations.has(key)) {

            var record = possibleLocations.get(key);

            if (idsLastSeen[key] > record.version) {
              //new winner
              possibleLocations.set(key, {
                version: idsLastSeen[key],
                stack: stack
              })
            }

          } else {
            //We're the first one that's been seen; add it.
            possibleLocations.set(key, {
              version: idsLastSeen[key],
              stack: stack
            })
          }

        }

      }

    }

    customElements.define(BoardgameComponentAnimator.is, BoardgameComponentAnimator);

  </script>
</dom-module>
