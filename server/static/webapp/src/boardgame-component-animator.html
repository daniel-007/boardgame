<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="boardgame-card-stack.html">

<dom-module id="boardgame-component-animator">
  <template>
    <boardgame-card-stack id='stack' no-default-spacer></boardgame-card-stack>
  </template>

  <script>

    class BoardgameComponentAnimator extends Polymer.Element {
      static get is() {
        return "boardgame-component-animator"
      }

      static get properties() {
        return {
          _infoById: Object,
          _lastSeenNodesById: Object,
          _beforeSeenIds: Object,
          _animatingCards: Array,
          _beforeCollectionOffsets: Object,
          ancestorOffsetParent: Object
        }
      }

      _calculateOffsets(ele) {

        var top = 0;
        var left = 0;
        var width = ele.offsetWidth;
        var height = ele.offsetHeight;

        var offsetEle = ele;
        while (offsetEle) {

          top += offsetEle.offsetTop;
          left += offsetEle.offsetLeft;

          if (offsetEle == this.ancestorOffsetParent) {
            offsetEle = null;
          } else {
            offsetEle = offsetEle.offsetParent;
          }
        }

        return {
          top: top,
          left: left,
          width: width,
          height: height
        };
      }

      ready() {
        super.ready();
        this._lastSeenNodesById = new Map();
      }

      prepare() {

        var collections = this.$.stack._sharedStackList;

        this._beforeCollectionOffsets = new Map();

        var result = {};

        //keep track of all of the ids we've seen this round to make sure we
        //found a home for all of them in the end.
        this._beforeSeenIds = new Set();

        for (var i = 0; i < collections.length; i++) {
          var collection = collections[i];

          var offsetCard = collection.offsetCard;
          this._beforeCollectionOffsets.set(collection.id, this._calculateOffsets(offsetCard));

          var cards = collection.Cards;
          for (var j = 0; j < cards.length; j++) {
            var card = cards[j];
            var record = result[card.id] || {};

            this._beforeSeenIds.add(card.id);

            record.offsets = this._calculateOffsets(card);

            //We use getComputedStyle instead of just card.style.transform,
            //because if the card is in the middle of transforming, we want
            //the exact value at that second, not what the logical final value
            //is.

            var computedStyle = getComputedStyle(card)

            record.previousTransform = computedStyle.transform;

            if (record.previousTransform == "none") {
              record.previousTransform = "";
            }

            record.beforeFaceUp = card.faceUp;
            record.beforeRotated = card.rotated;

            if (!card.noContent) {
              var newNodes = [];
              //If the card has old-front, that's a signal that content is bad
              //and not worth copying.
              var children = card.children;
              for (var k = 0; k < children.length; k++) {
                var child = children[k];
                if (child.slot) {
                  //Skip content that doesn't go in default slot
                  continue
                }
                newNodes.push(child.cloneNode(true));
              }
              if (newNodes.length > 0) {
                this._lastSeenNodesById.set(card.id, newNodes);
              }
            }
            result[card.id] = record;
          }
        }

        this._infoById = result;
      }

      animate() {
        window.requestAnimationFrame(()=> this._doAnimate());
      }

      _doAnimate() {
        var collections = this.$.stack._sharedStackList;

        //The last seen location of a given card ID
        var idToPossibleCollection = new Map();

        var collectionOffsets = new Map();

        //Turning off animations and setting card flip all require recalcing
        //style so do them once before readback in the second loop.

        for (var i = 0; i < collections.length; i++) {
          var collection = collections[i];
          collection.noAnimate = true;
          var cards = collection.Cards;
          for (var j = 0; j < cards.length; j++) {
            var card = cards[j];
            card.noAnimate = true; 
          }
        }

        //This layout readback is the most important thing to do quickly
        //because if we thrash the DOM there will be a lot of recalc style. So
        //do it in its own pass.
        for (var i = 0; i < collections.length; i++) {
          var collection = collections[i];

          var offsetCard = collection.offsetCard;
          collectionOffsets.set(collection.id, this._calculateOffsets(offsetCard));

          //Note which Ids were last seen here
          this._ingestStack(idToPossibleCollection, collection);

          var cards = collection.Cards;
          for (var j = 0; j < cards.length; j++) {
            var card = cards[j];
            var record = this._infoById[card.id];
            if (!record) {
              record = {};
              this._infoById[card.id] = record;
            }
            record.newOffsets = this._calculateOffsets(card);
          }
        }

        //This is the meat of the method, where we set all layout-affecting
        //properties, append fake dom, etc.
        for (var i = 0; i < collections.length; i++) {

          var collection = collections[i];

          var cards = collection.Cards;
          for (var j = 0; j < cards.length; j++) {
            var card = cards[j];
            var record = this._infoById[card.id];

            if (!record.offsets) {

              //Hmm, a record who didn't have its offsets set in prepare(),
              //presumably because it didn't exist. This MAY be an element who
              //came from a PolicyNonEmpty stack.

              var collectionRecord = idToPossibleCollection.get(card.id);

              if (!collectionRecord) {
                //Nah, we don't know where it came from. Just skip animating it.
                continue;
              }

              var theStack = collectionRecord.stack;
              //We actually want the runner up, if it exists. the winner is
              //the stack it's now in, and teh runner up should be where it
              //just came from.
              if (collectionRecord.runnerUpStack) {
                theStack = collectionRecord.runnerUpStack;
              }

              record.offsets = this._beforeCollectionOffsets.get(theStack.id);
              record.beforeFaceUp = false;
              

              record.postPreviousOpacity = card.style.opacity;
              record.postPreviousTransform = card.style.transform;

              theStack.setUnknownAnimationState(card);

              record.previousTransform = card.style.transform;

            } else {
              record.postPreviousOpacity = card.style.opacity;
              record.postPreviousTransform = card.style.transform;
            }

            //Mark that we've seen where this one is going.
            this._beforeSeenIds.delete(card.id);

            record.afterFaceUp = card.faceUp;

            //All of these set inner rotation on card, so do them all at once
            card.setProperties({
              faceUp: record.beforeFaceUp,
              overrideRotated: true,
              basicRotated: record.beforeRotated
            })

            var invertTop = record.offsets.top - record.newOffsets.top;
            var invertLeft = record.offsets.left - record.newOffsets.left;

            var scaleFactor= record.offsets.width / record.newOffsets.width;

            //If the before and after are rotated differently then the scale
            //factor will need to compare height vs width to get the right
            //scale factor.
            if (record.beforeRotated != card.rotated) {
              scaleFactor = record.offsets.height / record.newOffsets.width;
            }

            //The containing box has physically shrunk (or grown), and the
            //transform will make its apparent edge be that much smaller or
            //bigger, so correct for that.
            invertTop -= (record.newOffsets.height - record.offsets.height) / 2;
            invertLeft -= (record.newOffsets.width - record.offsets.width) / 2;

            //We used to only bother setting transforms for items that had
            //physically moved. However, the browser is smart enough to ignore
            //transforms that are basically no ops. And if we don't set it
            //then cards that don't physically move but do have transform
            //changes won't animate because the transform was set during
            //noAnimate and is never set to anything different. In testing
            //this didn't appear to have any appreciable performance difference.
            var transform = `translateY(${invertTop}px) translateX(${invertLeft}px)`
            var scaleTransform = `scale(${scaleFactor})`
            card.style.transform = transform + " " + record.previousTransform + " " + scaleTransform;

            var clonedNodes = this._lastSeenNodesById.get(card.id);

            if (clonedNodes && clonedNodes.length > 0) {

              //Clear out old nodes.
              for (var k = 0; k < card.children.length; k++) {
                var child = card.children[k];
                if (child.slot == "fallback") {
                  card.removeChild(child);
                }
              }
              for (var k = 0; k < clonedNodes.length; k++) {
                var node = clonedNodes[k];
                node.slot = "fallback";
                card.appendChild(node);
              }
            }
            
          }
        }


        this._animatingCards = [];

        //Any items still in _beforeSeenIds did not have a specific card to
        //animate to. Let's see if we can figure out which collection they
        //went to.
        for (let id of this._beforeSeenIds) {

          //Which stack do we think this is in now?
          var record = idToPossibleCollection.get(id);

          if (!record) {
            //Guess it's a mystery. :-(
            continue;
          }

          var card = record.stack.newAnimatingCard();

          var infoForCard = this._infoById[id]

          card.setProperties({
            faceUp: infoForCard.beforeFaceUp,
            overrideRotated: true,
            basicRotated: infoForCard.beforeRotated
          })

          this._animatingCards.push({
            stack: record.stack,
            card: card,
            postPreviousTransform: card.style.transform,
            postPreviousOpacity: card.style.opacity
          })

          var stackLocation = collectionOffsets.get(record.stack.id);
          var oldLocation = infoForCard.offsets;

          var invertTop = oldLocation.top - stackLocation.top;
          var invertLeft = oldLocation.left - stackLocation.left;

          //The containing box has physically shrunk (or grown), and the
          //transform will make its apparent edge be that much smaller or
          //bigger, so correct for that.
          invertTop -= (stackLocation.height - oldLocation.height) / 2;
          invertLeft -= (stackLocation.width - oldLocation.width) / 2;

          var scaleFactor= oldLocation.width / stackLocation.width;

          //If the before and after are rotated differently then the scale
          //factor will need to compare height vs width to get the right
          //scale factor.
          if (infoForCard.beforeRotated != record.stack.cardsRotated) {
            scaleFactor = stackLocation.height / oldLocation.width;
          }

          //We used to only bother setting transforms for items that had
          //physically moved. However, the browser is smart enough to ignore
          //transforms that are basically no ops. And if we don't set it
          //then cards that don't physically move but do have transform
          //changes won't animate because the transform was set during
          //noAnimate and is never set to anything different. In testing
          //this didn't appear to have any appreciable performance difference.
          var transform = `translateY(${invertTop}px) translateX(${invertLeft}px)`
          var scaleTransform = `scale(${scaleFactor})`
          card.style.transform = transform + " " + infoForCard.previousTransform + " " + scaleTransform;

          card.style.opacity = "1.0";

          var clonedNodes = this._lastSeenNodesById.get(id);
          if (clonedNodes) {
            for (var k = 0; k < clonedNodes.length; k++) {
              var node = clonedNodes[k];
              node.slot = "fallback";
              card.appendChild(node);
            }
          }
        }

        //Wait for styles to be set to do the animations
        window.requestAnimationFrame(() => this._startAnimations());

      }

      _startAnimations() {
        var collections = this.$.stack._sharedStackList;

        for (var i = 0; i < collections.length; i++) {
          var collection = collections[i];
          collection.noAnimate = false;
          var cards = collection.Cards;
          for (var j = 0; j < cards.length; j++) {
            var card = cards[j];
            var record = this._infoById[card.id];
            if (!record) continue;
            card.noAnimate = false;
            card.style.transform = record.postPreviousTransform;
            card.style.opacity = record.postPreviousOpacity;
            //All of these affect innerRotation on card, so do them all at
            //once. When they weren't batched we were getting odd transforms.
            card.setProperties({
              faceUp: record.afterFaceUp,
              overrideRotated: false,
              basicRotated: false
            });
          }
        }

        for (var i = 0; i < this._animatingCards.length; i++) {
          var record = this._animatingCards[i];
          record.card.noAnimate = false;
          record.card.setProperties({
            faceUp: false,
            basicRotated: record.stack.cardsRotated
          })

          record.card.style.opacity = record.postPreviousOpacity;
          record.card.style.transform = record.postPreviousTransform;
        }

      }

      _ingestStack(possibleLocations, stack) {

        var idsLastSeen = stack.idsLastSeen;

        for (var key in idsLastSeen) {
          if (!idsLastSeen.hasOwnProperty(key)) continue;

          if (possibleLocations.has(key)) {

            var record = possibleLocations.get(key);

            if (idsLastSeen[key] > record.version) {
              //new winner
              var newRecord = {
                version: idsLastSeen[key],
                stack: stack,
                runnerUpVersion: record.version,
                runnerUpStack: record.stack
              };
              possibleLocations.set(key, newRecord)
              record = newRecord;
            }

            if (!record.runnerUpStack || idsLastSeen[key] > record.runnerUpVersion) {
              //Found a new second!
              possibleLocations.set(key, {
                version: record.version,
                stack: record.stack,
                runnerUpVersion: idsLastSeen[key],
                runnerUpStack: stack
              })
            }

          } else {
            //We're the first one that's been seen; add it.
            possibleLocations.set(key, {
              version: idsLastSeen[key],
              stack: stack
            })
          }

        }

      }

    }

    customElements.define(BoardgameComponentAnimator.is, BoardgameComponentAnimator);

  </script>
</dom-module>
