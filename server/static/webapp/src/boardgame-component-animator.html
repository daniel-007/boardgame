<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="boardgame-card-collection.html">

<dom-module id="boardgame-component-animator">
  <template>
    <boardgame-card-collection id='collection' no-default-spacer></boardgame-card-collection>
  </template>

  <script>

    class BoardgameComponentAnimator extends Polymer.Element {
      static get is() {
        return "boardgame-component-animator"
      }

      static get properties() {
        return {
          _infoById: Object,
          ancestorOffsetParent: Object
        }
      }

      _calculateOffsets(ele) {
        var top = 0;
        var left = 0;

        var offsetEle = ele;
        while (offsetEle) {

          top += offsetEle.offsetTop;
          left += offsetEle.offsetLeft;

          if (offsetEle == this.ancestorOffsetParent) {
            offsetEle = null;
          } else {
            offsetEle = offsetEle.offsetParent;
          }
        }

        return {
          top: top,
          left: left
        };
      }

      prepare() {

        var collections = this.$.collection._sharedCollectionList;

        var result = this._infoById || {};

        for (var i = 0; i < collections.length; i++) {
          var collection = collections[i];
          var cards = collection.Cards;
          for (var j = 0; j < cards.length; j++) {
            var card = cards[j];
            var record = result[card.id] || {};

            record.offsets = this._calculateOffsets(card);

            //We use getComputedStyle instead of just card.style.transform,
            //because if the card is in the middle of transforming, we want
            //the exact value at that second, not what the logical final value
            //is.
            record.previousTransform = getComputedStyle(card).transform;

            record.beforeFaceUp = card.faceUp;

            if (!card.noContent) {
              var newNodes = [];
              //If the card has old-front, that's a signal that content is bad
              //and not worth copying.
              var children = card.children;
              for (var k = 0; k < children.length; k++) {
                var child = children[k];
                if (child.slot) {
                  //Skip content that doesn't go in default slot
                  continue
                }
                newNodes.push(child.cloneNode(true));
              }
              if (newNodes.length > 0) {
                record.clonedNodes = newNodes;
              }
            }
            result[card.id] = record;
          }
        }

        this._infoById = result;
      }

      animate() {
        window.requestAnimationFrame(()=> this._doAnimate());
      }

      _doAnimate() {
        var collections = this.$.collection._sharedCollectionList;

        //Turning off animations and setting card flip all require recalcing
        //style so do them once before readback in the second loop.

        for (var i = 0; i < collections.length; i++) {
          var collection = collections[i];
          collection.noAnimate = true;
          var cards = collection.Cards;
          for (var j = 0; j < cards.length; j++) {
            var card = cards[j];
            card.noAnimate = true; 
          }
        }

        //This layout readback is the most important thing to do quickly
        //because if we thrash the DOM there will be a lot of recalc style. So
        //do it in its own pass.
        for (var i = 0; i < collections.length; i++) {
          var collection = collections[i];
          var cards = collection.Cards;
          for (var j = 0; j < cards.length; j++) {
            var card = cards[j];
            var record = this._infoById[card.id];

            if (!record) continue;
            record.newOffsets = this._calculateOffsets(card);        
          }
        }

        //This is the meat of the method, where we set all layout-affecting
        //properties, append fake dom, etc.
        for (var i = 0; i < collections.length; i++) {

          var collection = collections[i];
          var cards = collection.Cards;
          for (var j = 0; j < cards.length; j++) {
            var card = cards[j];
            var record = this._infoById[card.id];

            if (!record) continue;

            record.postPreviousTransform = card.style.transform;

            record.afterFaceUp = card.faceUp;
            card.faceUp = record.beforeFaceUp;       

            //TODO: if calculating offsetTop,Left is expensive here, split all
            //reads into a separate pass before this

            var invertTop = record.offsets.top - record.newOffsets.top;
            var invertLeft = record.offsets.left - record.newOffsets.left;

            //We used to only bother setting transforms for items that had
            //physically moved. However, the browser is smart enough to ignore
            //transforms that are basically no ops. And if we don't set it
            //then cards that don't physically move but do have transform
            //changes won't animate because the transform was set during
            //noAnimate and is never set to anything different. In testing
            //this didn't appear to have any appreciable performance difference.
            var transform = `translateY(${invertTop}px) translateX(${invertLeft}px)`
            card.style.transform = transform + " " + record.previousTransform;

            if (record.clonedNodes && record.clonedNodes.length > 0) {

              //Clear out old nodes.
              for (var k = 0; k < card.children.length; k++) {
                var child = card.children[k];
                if (child.slot == "fallback") {
                  card.removeChild(child);
                }
              }
              for (var k = 0; k < record.clonedNodes.length; k++) {
                var node = record.clonedNodes[k];
                node.slot = "fallback";
                card.appendChild(node);
              }
            }
            
          }
        }

        //Wait for styles to be set to do the animations
        window.requestAnimationFrame(() => this._startAnimations());

      }

      _startAnimations() {
        var collections = this.$.collection._sharedCollectionList;

        for (var i = 0; i < collections.length; i++) {
          var collection = collections[i];
          collection.noAnimate = false;
          var cards = collection.Cards;
          for (var j = 0; j < cards.length; j++) {
            var card = cards[j];
            var record = this._infoById[card.id];
            if (!record) continue;
            card.noAnimate = false;
            card.style.transform = record.postPreviousTransform;
            card.faceUp = record.afterFaceUp;

          }
        }
      }

    }

    customElements.define(BoardgameComponentAnimator.is, BoardgameComponentAnimator);

  </script>
</dom-module>
