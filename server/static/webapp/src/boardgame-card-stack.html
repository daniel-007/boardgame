<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-repeat.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-if.html">
<link rel="import" href="boardgame-card.html">

<dom-module id="boardgame-card-stack">
  <template>
    <style>

      :host {
        width:100%;
      }

      #container {
        position: relative;
        @apply --layout-horizontal;
        @apply --layout-center;
      }

      #container #slot-holder {
        @apply --layout-horizontal;
        @apply --layout-center;
      }

      #animating-cards boardgame-card {
        /* don't mess with the general layout because the card will be gone soon */
        position: absolute;
      }

      #container ::slotted(boardgame-card), #container boardgame-card {
        transition: transform var(--animation-length, 0.25s) ease-in-out, opacity var(--animation-length, 0.25s) ease-in-out;
      }

      #container.no-animate ::slotted(boardgame-card), #container.no-animate boardgame-card {
        transition: unset;
      }

      #container.grid #slot-holder, #container.stack #slot-holder {
         @apply --layout-wrap;
      }

      #container ::slotted(boardgame-card), #container boardgame-card {
        margin: 1em;
      }

      /* most cards in stacks should be at the front, and a few pixels down so
      /* you can see them behind the first few cards */

      .stack ::slotted(boardgame-card), .stack boardgame-card {
        position: absolute;
        top: 6px;
        left: 0px;
      }

      /* the first child should actually take up layout space for the entire
      /* stack, and not be offset any. */

      .stack ::slotted(boardgame-card:first-child), .stack boardgame-card:first-child, .stack boardgame-card#spacer {
        z-index: 10;
        position: relative;
        top:0px;
      }

      /* The second card should stick out justa bit */

      .stack ::slotted(boardgame-card:nth-child(2)), .stack boardgame-card:nth-child(2) {
        top:2px;
        z-index: 9;
      }

      /* The third card should stick out just a bit more */

      .stack ::slotted(boardgame-card:nth-child(3)), .stack boardgame-card:nth-child(3) {
        z-index: 8;
        top:4px;
      }

      #container.spread #slot-holder {
        
        /* If we just applied layout-around-justified to #container.spread, it
        /* wouldn't work because the children are actually the four containers */
        @apply --layout-horizontal;
        @apply --layout-around-justified;
        width:100%;
      }

      #container.spread #slot-holder ::slotted(dom-repeat) {
        /* If we don't do this then oddly enough the dom-repeats will take up space in the layout! */
        display: none;
      }

      .spread ::slotted(boardgame-card:hover), .spread boardgame-card:hover, .fan ::slotted(boardgame-card:hover), .fan boardgame-card:hover {
        z-index:1;
      }

      #container.spread ::slotted(boardgame-card), #container.spread boardgame-card {
        /* default card width */
        margin-right: calc(100px * -0.75);
      }

      #container.spread ::slotted(boardgame-card.bcc-last), #container.spread boardgame-card.bcc-last {
        margin-right: 0;
      }

      #container.fan ::slotted(boardgame-card), #container.fan boardgame-card {
        /* default card width */
        margin-right: calc(100px * -0.5);
      }

      #container.fan ::slotted(boardgame-card[rotated]), #container.fan boardgame-card[rotated] {
        /* default card width */
        margin-right: calc(100px * -0.25);
      }

      #container.fan ::slotted(boardgame-card.bcc-last), #container.fan boardgame-card.bcc-last {
        margin-right: 0;
      }

      #container.fan {
        /* give a bit more vertical breathing room for the arc */
        box-sizing:border-box;
        padding: 1em 0;
      }

    </style>

    <div id="container" class$="{{_classes(layout, noAnimate)}}">
      <div id="slot-holder">
        <slot id="cards"></slot>
      </div>
      <template is="dom-if" if="{{_createSpacer}}" restamp>
          <boardgame-card spacer id="spacer" card-type="{{_effectiveCardType}}">
          </boardgame-card>
      </template>
      <div id="faux-cards">
        <template is="dom-repeat" id="faux-cards-repeater" items="{{_fauxCardsToAdd}}">
          <boardgame-card index="{{index}}" card-type="{{_effectiveCardType}}">
          </boardgame-card>
        </template>
      </div>
      <div id="animating-cards"></div>
    </div>
  </template>

  <script>

    var BoardgameCardStack;

    (function(){ 

      var sharedStackList = [];

      BoardgameCardStack = class extends Polymer.Element {

        static get is() {
          return "boardgame-card-stack"
        }

        static get properties() {
          return {
            //layout sets the layout style to use. One of `stack` (default),
            //`grid`, `spread` and `fan`
            layout: {
              type: String,
              observer: "_updateCardClasses",
              value: "stack"
            },
            //stack should be set to the state value corresponding to a stack.
            //It will set idsLastSeen, and also set the first dom-repeat it
            //finds as a child's items to stack.Components.
            stack : {
              type: Object,
              value: null,
              observer: "_stackChanged"
            },
            //If set, this stack will be combined with the secondary stack and 
            //the result will be set to stack.
            primaryStack: {
              type: Object,
              value: null
            },
            secondaryStack: {
              type: Object,
              value: null
            },
            //may be `overlap` (default) or `concatenate`
            stackCombine: {
              type: String,
              value: "overlap"
            },
            //if true, all cards will have a slight rotation transformation
            //applied to make the layout not look artificially tidy
            messy: {
              type: Boolean,
              value: false,
              observer: "_updateCardClasses"
            },
            //If the cards are messy, how messy are they? 1.0 is default
            //messiness, 2.0 is twice as messy.
            messiness: {
              type: Number,
              value: 1.0,
              observer: "_updateCardClasses"
            },
            //idsLastSeen should be the IdsLastSeen for the stack that this
            //stack represents. boardgame-component-animator will use this
            //value to figure out where to animate from and to.
            idsLastSeen: Object,
            //if true, animations will be suppressed
            noAnimate: Boolean,
            //If there are no cards, by default we'll inject a single spacer
            //(invisibled) card, just to make sure the overall layout doesn't
            //jump when a card is added to this stack. If this property is
            //true, we won't do that.
            noDefaultSpacer: Boolean,
            //If there aren't more than fauxCards "real" cards in the stack,
            //we'll make fake cards until there are this many cards. This is
            //useful if you have, for example, a very big draw deck and only
            //want to actually render the first few cards.
            fauxCards: {
              type: Number,
              value: 0
            },
            _createSpacer: Boolean,
            _fauxCardsToAdd: Array,
            _randomRotationOffset: {
              type: Number,
              value: 0
            },
            _effectiveCardType: {
              type: String,
              computed: "_computeEffectiveCardType(stack)"
            }
          }
        }

        static get observers() {
          return [
            '_updateDerivedStack(primaryStack, secondaryStack, stackCombine)'
          ]
        }

        get _sharedStackList() {
          return sharedStackList;
        }

        _computeEffectiveCardType(stack) {
          if (!stack) return "";
          var deck = stack.Deck;
          if (!deck) return "";
          return "deck-" + deck + "-card";
        }

        //returns true if it appears that at least some cards in this stack
        //are rotated.
        get cardsRotated() {
          var cards = this.Cards;
          var rotatedCards = 0;
          var totalCards = 0;
          for (var i = 0; i < cards.length; i++) {
            totalCards++;
            if (cards[i].rotated) {
              rotatedCards++
            }
          }

          if (!totalCards) {
            return false;
          }

          return (rotatedCards / totalCards > 0.5);

        }

        connectedCallback() {
          sharedStackList.push(this);
        }

        disconnectedCallback() {
          var i = 0;
          while (i < sharedStackList.length) {
            var item = sharedStackList[i];
            if (i == this) {
              sharedStackList.splice(i, 1);
            } else {
              i++;
            }
          }
        }

        //offsetCard returns a card in the stack to use for positioning.
        get offsetCard() {
          var cards = this._realCards;
          if (cards.length > 0) return cards[0];
          var card = this.shadowRoot.querySelector("boardgame-card");
          if (card) return card;
          return this;
        }

        //id will be set to a long, stable Id for this stack during its
        //lifetime. Primarily useful to identify itself to the animation-
        //coordinator.
        get id() {
          return this._id;
        }

        ready() {
          super.ready();
          this.$.cards.addEventListener("slotchange", () => this._slotChanged());
          //If the children are already stamped, update now.
          this._slotChanged();
          //Generate a random rotation offset from 0 to 20 that will make this
          //stack have rotatons that are stable as long as the stack exists
          //(which it will in general because Polymer databinding will reuse
          //elements) but different from most other stacks.
          this._randomRotationOffset = Math.floor(Math.random() * 21);
          this._id = this._randomId(8);
        }

        //setUnknownAnimationState sets the "final" state of the styling on a
        //card that is flying to the unknown state. Used by boardgame-
        //component-animator.
        setUnknownAnimationState(card) {
          card.style.transform = "scale(0.6)";
          card.style.opacity = "0.0";
        }

        //Returns a new card to animate its position. When its transition ends it will be removed.
        newAnimatingCard() {
          var card = document.createElement("boardgame-card");
          card.noAnimate = true;
          card.noContent = true;
          this.setUnknownAnimationState(card);
          this.$["animating-cards"].appendChild(card);
          card.addEventListener("transitionend", e => this._clearAnimatingCards(e));
          return card;
        }

        _clearAnimatingCards(e) {
          var container = this.$['animating-cards'];
          while(container.children.length > 0) {
            var child = container.children[0];
            container.removeChild(child);
          }
        }

        _stackChanged(newValue) {
          if (!newValue) return;
          this.idsLastSeen = newValue.IdsLastSeen || {};
          var repeater = this.querySelector("dom-repeat");
          if (!repeater) {
            console.warn("Couldn't find a repeater to stamp stack items into")
            return;
          }
          repeater.items = newValue.Components;
        }

        _updateDerivedStack(primaryStack, secondaryStack, stackCombine) {
          if (!primaryStack && !secondaryStack) return;
          if (primaryStack && !secondaryStack) {
            this.stack = primaryStack;
            return;
          }
          if (secondaryStack && !primaryStack) {
            this.stack = secondaryStack;
            return;
          }

          //If we get to here we have values for both stacks.

          if (primaryStack.Deck != secondaryStack.Deck) {
            console.warn("Primary and Secondary stacks are of different decks, which is not allowed")
            return;
          }

          if (!this._sanityCheckStack(primaryStack)) {
            console.warn("Primary stack didn't sanity check")
            return;
          }

          if (!this._sanityCheckStack(secondaryStack)) {
            console.warn("Secondary stack didn't sanity check")
            return;
          }

          var result = this._copyObj(primaryStack);

          if (stackCombine == "concatenate") {
            for (var i = 0; i < secondaryStack.Components.length; i++) {
              result.Components.push(secondaryStack.Components[i]);
              result.Ids.push(secondaryStack.Ids[i]);
              result.Indexes.push(secondaryStack.Indexes[i]);
            }
          } else {
            //Default to "overlap"
            if (primaryStack.Components.length != secondaryStack.Components.length) {
              console.warn("Overlap combination but stacks were not equal length")
              return;
            }
            for (var i = 0; i < primaryStack.Components.length; i++) {
              if (result.Components[i]) {
                //If the primary already has an item, no need to fill in from secondary.
                continue;
              }
              result.Components[i] = secondaryStack.Components[i];
              result.Ids[i] = secondaryStack.Ids[i];
              result.Indexes[i] = secondaryStack.Indexes[i];
            }
          }

          //Go through each id in IdsLastSeen, if it's already in the result's
          //map, then overwrite only if index is greater.

          for (let attr in secondaryStack.IdsLastSeen) {
            if (!secondaryStack.IdsLastSeen.hasOwnProperty(attr)) continue;
            if (result.IdsLastSeen[attr]) {
              //If that id was already in the result, only overwrite if our version is higher.
              if (result.IdsLastSeen[attr] < secondaryStack.IdsLastSeen[attr]) {
                result.IdsLastSeen[attr] = secondaryStack.IdsLastSeen[attr];
              }
            } else {
              result.IdsLastSeen[attr] = secondaryStack.IdsLastSeen[attr];
            }
          }

          this.stack = result;

        }

        _sanityCheckStack(stack) {

          if (!stack) return false;

          if (!stack.Components || !stack.Ids || !stack.Indexes || !stack.IdsLastSeen) {
            return false;
          }

          if (stack.Components.length != stack.Ids.length) return false;
          if (stack.Components.length != stack.Indexes.length) return false;

          return true;
        }

        get _realCards() {
          var cards = this.$.cards.assignedNodes();

          var result = [];

          for (var i = 0; i < cards.length; i++) {
            var card = cards[i];

            if (!card.localName || card.localName != "boardgame-card") {
              //Skip text nodes and nodes that aren't cards
              continue;
            }

            result.push(card);
          }

          return result;
        }

        get _fauxCards() {
          var fauxCards = this.$['faux-cards'].querySelectorAll("boardgame-card");

          return [...fauxCards];
        }

        get Cards() {
          return this._realCards.concat(this._fauxCards);
        }

        _slotChanged() {

          var realCards = this._realCards;

          if (realCards.length < this.fauxCards) {
            this._fauxCardsToAdd = new Array(this.fauxCards - realCards.length);
            this.$['faux-cards-repeater'].render();
          }

          if (realCards.length < 1 && !this.noDefaultSpacer) {
            this._createSpacer = true;
          } else {
            this._createSpacer = false;
          }

          this._updateCardClasses();

        }

        _updateCardClasses() {

          //Called when layout changes, or when items are added or removed from
          //the slot.

          //TODO: the fact that we do this imperatively (and trample on whatever
          //shadow setting was explicilty set by the element to start) seems
          //like a smell. However, doing this just with CSS was quite hard.

          var cards = this.Cards;

          for (var i = 0; i < cards.length; i++) {
            var card = cards[i];

            var classes = ["bcc-last"];

            for (var j = 0; j < classes.length; j++) {
              card.classList.remove(classes[j]);
            }

            if (this.messy) {
              card.style.transform = "rotate(" + this._messyRotationForIndex(i) + "deg)";
            } else {
              //_fanCards assumes that the transform has been "reset" in this layout pass.
              card.style.transform = "";
            }

            if (i == cards.length - 1) {
              card.classList.add("bcc-last");
            }

            if (this.layout != "stack") {
              card.noShadow = false;
              continue
            }

            if (i < 4) {
              card.noShadow = false;
            } else {
              card.noShadow = true;
            }
          }

          if (this.layout == "fan") {
            this._fanCards();
          }

        }

        _fanCards() {
          var cards = this.Cards;

          //TODO: set the amount of max rotation based on length of stack;
          var maxRotation = 20;
          var minRotation = maxRotation * -1;
          
          var maxTranslate = -1.0;
          var minTranslate = 1.5;
          
          if (cards.length < 8 && this.cardsRotated || !this.cardsRotated && cards.length < 3) {
            var percent = 0.5
            maxRotation *= percent;
            minRotation *= percent;
            maxTranslate *= percent;
            minTranslate *= percent;
          }

          var rotationSpread = maxRotation - minRotation;
          var translateSpread = maxTranslate - minTranslate;


          for (var i = 0; i < cards.length; i++) {
              var card = cards[i];

              var percent = (i / (cards.length - 1));

              var rotation = percent * rotationSpread + minRotation;

              //TODO: preserve the messiness transformations
              var rotationTransformation = "rotate(" + rotation + "deg)";

              var translateRadians = 3.0 * percent - 1.5;

              if (percent < 0) {
                translateRadians = translateRadians * -1;
              }

              var translate = Math.cos(translateRadians) * translateSpread + minTranslate;

              var translateTransformation = "translateY(" + translate + "em)";

              card.style.transform += rotationTransformation + " " + translateTransformation;

          }

        }

        _messyRotationForIndex(index) {

          var values = [-0.6, 1.6, -2.8, 2.4, -1.6, 3.0, -0.6, -2.4, -3.6, 1.4, -1.8, 1.8, 0.2, 3.6, 1.4, -1.0];

          index = (index  + this._randomRotationOffset) % values.length;

          return values[index] * this.messiness;

        }

        _classes(layout, noAnimate) {
          var result = [];
          if (layout) {
            result.push(layout);
          }
          if (noAnimate) {
            result.push("no-animate");
          }
          return result.join(" ");
        }

        _copyObj(obj) {
          let copy = {}
          for (let attr in obj) {
            if (obj.hasOwnProperty(attr)) copy[attr] = obj[attr]
          }
          return copy
        }

        _randomId(length) {
            var text = "";
            var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

            for( var i=0; i < length; i++ ) {
              text += possible.charAt(Math.floor(Math.random() * possible.length));
            }

            return text;
        }
      } 

    })();

    customElements.define(BoardgameCardStack.is, BoardgameCardStack);
  </script>
</dom-module>
