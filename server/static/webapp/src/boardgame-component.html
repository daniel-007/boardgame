<link rel="import" href="../bower_components/polymer/polymer-element.html">

<dom-module id="boardgame-component">

  <template>
    <style>
      :root {
        /* These are copied and lightly modified from paper-styles/shadow, because we need rotated versions, too. */
        --shadow-elevation-normal: {
          box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14),
                      0 1px 5px 0 rgba(0, 0, 0, 0.12),
                      0 3px 1px -2px rgba(0, 0, 0, 0.2);
        };

        --shadow-elevation-raised: {
          box-shadow: 0 8px 10px 1px rgba(0, 0, 0, 0.14),
                      0 3px 14px 2px rgba(0, 0, 0, 0.12),
                      0 5px 5px -3px rgba(0, 0, 0, 0.4);
        };

      }

      .spacer {
        visibility: hidden;
      }

      #outer.interactive {
        cursor: pointer;
      }

      .no-animate #inner {
        transition: unset;
      }

      .disabled {
        filter: saturate(60%);
      }

      #outer {
        cursor: default;
      }

      #outer.shadow #inner {
        @apply --shadow-elevation-normal;
      }

      #outer.shadow.interactive:hover #inner {
        @apply --shadow-elevation-raised;
      }

      #inner {
        /* The second part of this transition is from paper-styles/shadow, because we need to do our own to get rotated */
        transition: transform var(--animation-length, 0.25s) ease-in-out, box-shadow 0.28s cubic-bezier(0.4, 0, 0.2, 1);
      }

    </style>

    <!-- subclass style should be inserted here -->

    <div id="outer" class$="{{_classes}}" on-tap="handleTap">
      <div id="inner">
        <!-- subclass content should be inserted here -->
      </div>
    </div>


  </template>

  <script>
    class BoardgameComponent extends Polymer.Element {

      static get is() {
        return "boardgame-component"
      }

      static get properties() {
        return {
          //Index is the index of this card in the stack. Included in
          //component-tapped events.
          index: Number,
          //If item is set, it is assumed to be a Component from a stack in a
          //state. faceUp, coContent, spacer, and id will all be set based on
          //its value. A convenient way to stamp out cards with minimal fuss
          //in the default case.
          item: {
            type: Object,
            observer: "_itemChanged"
          },
          //If true, no animations will be played.
          noAnimate: {
            type: Boolean,
            value: false
          },
          //id  should be set to the component's Id from the framework.
          //boardgame-component-animator will look for this id to figure out
          //which cards are logically the same and thus should be animated
          //from one place to another.
          id: String,
          //if true, the card will be rendered differently, no component-
          //tapped events will be triggered.
          disabled: {
            type: Boolean,
            value: false
          },
          //True if the card is neither disabled nor a spacer.
          interactive: {
            type: Boolean,
            readOnly: true,
            computed: "_computeInteractive(spacer, disabled)"
          },
          //If true, the card is "empty" and should take up space but not
          //render a card. Useful for sizedStacks that have an empty slot.
          spacer: {
            type: Boolean,
            reflectToAttribute: true,
            value: false
          },
          //if true, no drop-shadow will be rendered. boardgame-card- stack
          //will set this in some cases, like in a stack, so that all of the
          //shadows for 10's of cards don't multiply together.
          noShadow: Boolean,

          //set _classes to change the classes that are set. call
          //_updateClasses() and it will call _computedClasses. When you
          //override _computedClasses, just add a new item in the observers
          //array that lists all the dependencies. Idelaly this would just be
          //a computed property thta you'd override how it was computed in
          //subclasses, but Polymer doesn't let you re-define a computed
          //property in a subclass.
          _classes: {
            type: String,
          }
        }
      }

      static get observers() {
        return [
          "_updateClasses(spacer, noShadow, interactive, disabled, noAnimate)",
        ]
      }

      //Returns a template for the subclass. The subtemplate's style will be
      //inserted right after the super template's style, and then the node
      //iwth id of Import will be imported inside of inner.
      static combinedTemplate(subTemplate) {
        let content = BoardgameComponent.template

        let result = document.importNode(content, true);

        let styleEle = subTemplate.content.querySelector("style");

        let injectionSite = result.content.children[1];

        result.content.insertBefore(styleEle,injectionSite);

        let innerEle = result.content.querySelector("#inner")

        let eleToImport = subTemplate.content.querySelector("#import")

        innerEle.appendChild(eleToImport);

        return result;
      }

      _updateClasses() {
        //We can ignore the arguments, all that's necessary is that we're
        //called whenever the value could have changed.
        this._classes = this._computeClasses();
      }

      handleTap(e) {
        if (!this.interactive) {
          return;
        }
        this.dispatchEvent(new CustomEvent('component-tapped', {composed: true, detail: {index: this.index}}));
      }

      _itemChanged(newValue) {
        if (newValue === undefined) return;
        if (newValue === null) {
          this.spacer = true;
          return;
        }
        this.id = newValue.Id || "";
      }

      _computeInteractive(spacer, disabled) {
        return !spacer && !disabled;
      }

      _computeClasses() {
        let result = [];
        if (this.spacer) {
          result.push("spacer");
        }
        if (!this.noShadow) {
          result.push("shadow");
        }
        if (this.interactive) {
          result.push("interactive");
        }
        if (this.disabled) {
          result.push("disabled");
        }
        if (this.noAnimate) {
          result.push("no-animate")
        }
        return result.join(" ");
      }

    }

    customElements.define(BoardgameComponent.is, BoardgameComponent);
  </script>
</dom-module>
