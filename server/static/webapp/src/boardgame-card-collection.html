<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-repeat.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-if.html">
<link rel="import" href="boardgame-card.html">

<dom-module id="boardgame-card-collection">
  <template>
    <style>

      #container {
        position: relative;
        @apply --layout-horizontal;
        @apply --layout-center;
      }

      #container ::slotted(boardgame-card), #container boardgame-card {
        transition: transform var(--animation-length, 0.25s) ease-in-out;
      }

      #container.no-animate ::slotted(boardgame-card), #container.no-animate boardgame-card {
        transition: unset;
      }

      #container.grid, #container.stack {
         @apply --layout-wrap;
      }

      #container ::slotted(boardgame-card), #container boardgame-card {
        margin: 1em;
      }

      /* most cards in stacks should be at the front, and a few pixels down so
      /* you can see them behind the first few cards */

      .stack ::slotted(boardgame-card), .stack boardgame-card {
        position: absolute;
        top: 6px;
        left: 0px;
      }

      /* the first child should actually take up layout space for the entire
      /* stack, and not be offset any. */

      .stack ::slotted(boardgame-card:first-child), .stack boardgame-card:first-child, .stack boardgame-card#spacer {
        z-index: 10;
        position: relative;
        top:0px;
      }

      /* The second card should stick out justa bit */

      .stack ::slotted(boardgame-card:nth-child(2)), .stack boardgame-card:nth-child(2) {
        top:2px;
        z-index: 9;
      }

      /* The third card should stick out just a bit more */

      .stack ::slotted(boardgame-card:nth-child(3)), .stack boardgame-card:nth-child(3) {
        z-index: 8;
        top:4px;
      }

      #container.spread {
        @apply --layout-around-justified;
      }

      .spread ::slotted(boardgame-card:hover), .spread boardgame-card:hover, .fan ::slotted(boardgame-card:hover), .fan boardgame-card:hover {
        z-index:1;
      }

      #container.spread ::slotted(boardgame-card), #container.spread boardgame-card {
        margin-right: -6.0em;
      }

      #container.spread ::slotted(boardgame-card.bcc-last), #container.spread boardgame-card.bcc-last {
        margin-right: 0;
      }

      #container.fan ::slotted(boardgame-card), #container.fan boardgame-card {
        margin-right: -3.0em;
      }

      #container.fan ::slotted(boardgame-card.bcc-last), #container.fan boardgame-card.bcc-last {
        margin-right: 0;
      }

      #container.fan {
        /* give a bit more vertical breathing room for the arc */
        box-sizing:border-box;
        padding: 1em 0;
      }

    </style>

    <div id="container" class$="{{_classes(layout, noAnimate)}}">
      <slot id="cards"></slot>
      <template is="dom-if" if="{{_createSpacer}}">
          <boardgame-card spacer id="spacer"></boardgame-card>
      </template>
      <div id="faux-cards">
        <template is="dom-repeat" id="faux-cards-repeater" items="{{_fauxCardsToAdd}}">
          <boardgame-card index="{{index}}"></boardgame-card>
        </template>
      </div>
    </div>
  </template>

  <script>

    var BoardgameCardCollection;

    (function(){ 

      var sharedCollectionList = [];

      BoardgameCardCollection = class extends Polymer.Element {

        static get is() {
          return "boardgame-card-collection"
        }

        static get properties() {
          return {
            layout: {
              type: String,
              observer: "_updateCardClasses"
            },
            //stack should be set to the state value corresponding to a stack.
            //It will set idsLastSeen, and also set the first dom-repeat it
            //finds as a child's items to stack.Components.
            stack : {
              type: Object,
              value: null,
              observer: "_stackChanged"
            },
            //If set, this stack will be combined with the secondary stack and 
            //the result will be set to stack.
            primaryStack: {
              type: Object,
              value: null
            },
            secondaryStack: {
              type: Object,
              value: null
            },
            //may be `overlap` (default) or `concatenate`
            stackCombine: {
              type: String,
              value: "overlap"
            },
            messy: Boolean,
            idsLastSeen: Object,
            noAnimate: Boolean,
            noDefaultSpacer: Boolean,
            fauxCards: {
              type: Number,
              value: 0
            },
            _createSpacer: Boolean,
            _fauxCardsToAdd: Array
          }
        }

        static get observers() {
          return [
            '_updateDerivedStack(primaryStack, secondaryStack, stackCombine)'
          ]
        }

        get _sharedCollectionList() {
          return sharedCollectionList;
        }

        connectedCallback() {
          sharedCollectionList.push(this);
        }

        disconnectedCallback() {
          var i = 0;
          while (i < sharedCollectionList.length) {
            var item = sharedCollectionList[i];
            if (i == this) {
              sharedCollectionList.splice(i, 1);
            } else {
              i++;
            }
          }
        }

        ready() {
          super.ready();
          this.$.cards.addEventListener("slotchange", () => this._slotChanged());
          //If the children are already stamped, update now.
          this._slotChanged();
        }

        _stackChanged(newValue) {
          if (!newValue) return;
          this.idsLastSeen = newValue.IdsLastSeen || {};
          var repeater = this.querySelector("dom-repeat");
          if (!repeater) {
            console.warn("Couldn't find a repeater to stamp stack items into")
            return;
          }
          repeater.items = newValue.Components;
        }

        _updateDerivedStack(primaryStack, secondaryStack, stackCombine) {
          if (!primaryStack && !secondaryStack) return;
          if (primaryStack && !secondaryStack) {
            this.stack = primaryStack;
            return;
          }
          if (secondaryStack && !primaryStack) {
            this.stack = secondaryStack;
            return;
          }

          //If we get to here we have values for both stacks.

          if (primaryStack.Deck != secondaryStack.Deck) {
            console.warn("Primary and Secondary stacks are of different decks, which is not allowed")
            return;
          }

          if (!this._sanityCheckStack(primaryStack)) {
            console.warn("Primary stack didn't sanity check")
            return;
          }

          if (!this._sanityCheckStack(secondaryStack)) {
            console.warn("Secondary stack didn't sanity check")
            return;
          }

          var result = this._copyObj(primaryStack);

          if (stackCombine == "concatenate") {
            for (var i = 0; i < secondaryStack.Components.length; i++) {
              result.Components.push(secondaryStack.Components[i]);
              result.Ids.push(secondaryStack.Ids[i]);
              result.Indexes.push(secondaryStack.Indexes[i]);
            }
          } else {
            //Default to "overlap"
            if (primaryStack.Components.length != secondaryStack.Components.length) {
              console.warn("Overlap combination but stacks were not equal length")
              return;
            }
            for (var i = 0; i < primaryStack.Components.length; i++) {
              if (result.Components[i]) {
                //If the primary already has an item, no need to fill in from secondary.
                continue;
              }
              result.Components[i] = secondaryStack.Components[i];
              result.Ids[i] = secondaryStack.Ids[i];
              result.Indexes[i] = secondaryStack.Indexes[i];
            }
          }

          //Go through each id in IdsLastSeen, if it's already in the result's
          //map, then overwrite only if index is greater.

          for (let attr in secondaryStack.IdsLastSeen) {
            if (!secondaryStack.IdsLastSeen.hasOwnProperty(attr)) continue;
            if (result.IdsLastSeen[attr]) {
              //If that id was already in the result, only overwrite if our version is higher.
              if (result.IdsLastSeen[attr] < secondaryStack.IdsLastSeen[attr]) {
                result.IdsLastSeen[attr] = secondaryStack.IdsLastSeen[attr];
              }
            } else {
              result.IdsLastSeen[attr] = secondaryStack.IdsLastSeen[attr];
            }
          }

          this.stack = result;

        }

        _sanityCheckStack(stack) {

          if (!stack) return false;

          if (!stack.Components || !stack.Ids || !stack.Indexes || !stack.IdsLastSeen) {
            return false;
          }

          if (stack.Components.length != stack.Ids.length) return false;
          if (stack.Components.length != stack.Indexes.length) return false;

          return true;
        }

        get _realCards() {
          var cards = this.$.cards.assignedNodes();

          var result = [];

          for (var i = 0; i < cards.length; i++) {
            var card = cards[i];

            if (!card.localName || card.localName != "boardgame-card") {
              //Skip text nodes and nodes that aren't cards
              continue;
            }

            result.push(card);
          }

          return result;
        }

        get _fauxCards() {
          var fauxCards = this.$['faux-cards'].querySelectorAll("boardgame-card");

          return [...fauxCards];
        }

         get Cards() {
          return this._realCards.concat(this._fauxCards);
        }

        _slotChanged() {

          var realCards = this._realCards;

          if (realCards.length < this.fauxCards) {
            this._fauxCardsToAdd = new Array(this.fauxCards - realCards.length);
            this.$['faux-cards-repeater'].render();
          }

          if (realCards.length < 1 && !this.noDefaultSpacer) {
            this._createSpacer = true;
          } else {
            this._createSpacer = false;
          }

          this._updateCardClasses();

        }

        _updateCardClasses() {

          //Called when layout changes, or when items are added or removed from
          //the slot.

          //TODO: the fact that we do this imperatively (and trample on whatever
          //shadow setting was explicilty set by the element to start) seems
          //like a smell. However, doing this just with CSS was quite hard.

          var cards = this.Cards;

          for (var i = 0; i < cards.length; i++) {
            var card = cards[i];

            var classes = ["bcc-last"];

            for (var j = 0; j < classes.length; j++) {
              card.classList.remove(classes[j]);
            }

            if (this.messy) {
              card.style.transform = "rotate(" + this._messyRotationForIndex(i) + "deg)";
            }

            if (i == cards.length - 1) {
              card.classList.add("bcc-last");
            }

            if (this.layout != "stack") {
              card.noShadow = false;
              continue
            }

            if (i < 4) {
              card.noShadow = false;
            } else {
              card.noShadow = true;
            }
          }

          if (this.layout == "fan") {
            this._fanCards();
          }

        }

        _fanCards() {
          var cards = this.Cards;

          //TODO: set the amount of max rotation based on length of stack;
          var maxRotation = 20;
          var minRotation = maxRotation * -1;
          var rotationSpread = maxRotation - minRotation;

          var maxTranslate = -1.0;
          var minTranslate = 1.5;
          var translateSpread = maxTranslate - minTranslate;

          for (var i = 0; i < cards.length; i++) {
              var card = cards[i];

              var percent = (i / (cards.length - 1));

              var rotation = percent * rotationSpread + minRotation;

              //TODO: preserve the messiness transformations
              var rotationTransformation = "rotate(" + rotation + "deg)";

              var translateRadians = 3.0 * percent - 1.5;

              if (percent < 0) {
                translateRadians = translateRadians * -1;
              }

              var translate = Math.cos(translateRadians) * translateSpread + minTranslate;

              var translateTransformation = "translateY(" + translate + "em)";

              card.style.transform += rotationTransformation + " " + translateTransformation;

          }

        }

        _messyRotationForIndex(index) {

          var values = [-0.3, 0.8, -1.4, 1.2, -0.8, 1.5, -0.3, -1.2, -1.8, 0.7, -0.9, 0.9, 0.1, 1.8, 0.7, -0.5];

          index = index % values.length;

          return values[index];

        }

        _classes(layout, noAnimate) {
          var result = [];
          if (layout) {
            result.push(layout);
          }
          if (noAnimate) {
            result.push("no-animate");
          }
          return result.join(" ");
        }

        _copyObj(obj) {
          let copy = {}
          for (let attr in obj) {
            if (obj.hasOwnProperty(attr)) copy[attr] = obj[attr]
          }
          return copy
        }

      }

    })();

    customElements.define(BoardgameCardCollection.is, BoardgameCardCollection);
  </script>
</dom-module>
