<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-repeat.html">
<link rel="import" href="boardgame-card.html">

<dom-module id="boardgame-card-collection">
  <template>
    <style>

      #container {
        position: relative;
        @apply --layout-horizontal;
        @apply --layout-center;
      }

      #container.grid, #container.stack {
         @apply --layout-wrap;
      }

      #container ::slotted(boardgame-card), #container boardgame-card {
        margin: 1em;
      }

      /* most cards in stacks should be at the front, and a few pixels down so
      /* you can see them behind the first few cards */

      .stack ::slotted(boardgame-card), .stack boardgame-card {
        position: absolute;
        top: 6px;
        left: 0px;
      }

      /* the first child should actually take up layout space for the entire
      /* stack, and not be offset any. */

      .stack ::slotted(boardgame-card:first-child), .stack boardgame-card:first-child {
        z-index: 10;
        position: relative;
        top:0px;
      }

      /* The second card should stick out justa bit */

      .stack ::slotted(boardgame-card:nth-child(2)), .stack boardgame-card:nth-child(2) {
        top:2px;
        z-index: 9;
      }

      /* The third card should stick out just a bit more */

      .stack ::slotted(boardgame-card:nth-child(3)), .stack boardgame-card:nth-child(3) {
        z-index: 8;
        top:4px;
      }

      #container.spread {
        @apply --layout-around-justified;
      }

      .spread ::slotted(boardgame-card:hover), .spread boardgame-card:hover, .fan ::slotted(boardgame-card:hover), .fan boardgame-card:hover {
        z-index:1;
      }

      #container.spread ::slotted(boardgame-card), #container.spread boardgame-card {
        margin-right: -6.0em;
      }

      #container.spread ::slotted(boardgame-card.bcc-last), #container.spread boardgame-card.bcc-last {
        margin-right: 0;
      }

      #container.fan ::slotted(boardgame-card), #container.fan boardgame-card {
        margin-right: -3.0em;
      }

      #container.fan ::slotted(boardgame-card.bcc-last), #container.fan boardgame-card.bcc-last {
        margin-right: 0;
      }

      #container.fan {
        /* give a bit more vertical breathing room for the arc */
        box-sizing:border-box;
        padding: 1em 0;
      }

    </style>

    <div id="container" class$="{{_classes(layout, messy)}}">
      <slot id="cards"></slot>
      <template is="dom-repeat" items="{{_fauxCardsToAdd}}">
        <boardgame-card index="{{index}}"></boardgame-card>
      </template>
    </div>
  </template>

  <script>

    class BoardgameCardCollection extends Polymer.Element {

      static get is() {
        return "boardgame-card-collection"
      }

      static get properties() {
        return {
          layout: {
            type: String,
            observer: "_updateCardClasses"
          },
          messy: Boolean,
          fauxCards: {
            type: Number,
            value: 0
          },
          _fauxCardsToAdd: Array
        }
      }

      ready() {
        super.ready();
        this.$.cards.addEventListener("slotchange", () => this._slotChanged());
        //If the children are already stamped, update now.
        this._slotChanged();
      }

      _realCards() {
        var cards = this.$.cards.assignedNodes();

        var result = [];

        for (var i = 0; i < cards.length; i++) {
          var card = cards[i];

          if (!card.localName || card.localName != "boardgame-card") {
            //Skip text nodes and nodes that aren't cards
            continue;
          }

          result.push(card);
        }

        return result;
      }

      _fauxCards() {
        var fauxCards = this.$.container.querySelectorAll("boardgame-card");

        return [...fauxCards];
      }

      _allCards() {
        return this._realCards().concat(this._fauxCards());
      }

      _slotChanged() {

        var realCards = this._realCards();

        if (realCards.length < this.fauxCards) {
          this._fauxCardsToAdd = new Array(this.fauxCards - realCards.length);
        }

        window.requestAnimationFrame(() => this._updateCardClasses());

      }

      _updateCardClasses() {

        //Called when layout changes, or when items are added or removed from
        //the slot.

        //TODO: the fact that we do this imperatively (and trample on whatever
        //shadow setting was explicilty set by the element to start) seems
        //like a smell. However, doing this just with CSS was quite hard.

        var cards = this._allCards();

        for (var i = 0; i < cards.length; i++) {
          var card = cards[i];

          var classes = ["bcc-last"];

          for (var j = 0; j < classes.length; j++) {
            card.classList.remove(classes[j]);
          }

          if (this.messy) {
            card.style.transform = "rotate(" + this._messyRotationForIndex(i) + "deg)";
          }

          if (i == cards.length - 1) {
            card.classList.add("bcc-last");
          }

          if (this.layout != "stack") {
            card.noShadow = false;
            continue
          }

          if (i < 4) {
            card.noShadow = false;
          } else {
            card.noShadow = true;
          }
        }

        if (this.layout == "fan") {
          this._fanCards();
        }

      }

      _fanCards() {
        var cards = this._allCards();

        //TODO: set the amount of max rotation based on length of stack;
        var maxRotation = 20;
        var minRotation = maxRotation * -1;
        var rotationSpread = maxRotation - minRotation;

        var maxTranslate = -1.0;
        var minTranslate = 1.5;
        var translateSpread = maxTranslate - minTranslate;

        for (var i = 0; i < cards.length; i++) {
            var card = cards[i];

            var percent = (i / (cards.length - 1));

            var rotation = percent * rotationSpread + minRotation;

            //TODO: preserve the messiness transformations
            var rotationTransformation = "rotate(" + rotation + "deg)";

            var translateRadians = 3.0 * percent - 1.5;

            if (percent < 0) {
              translateRadians = translateRadians * -1;
            }

            var translate = Math.cos(translateRadians) * translateSpread + minTranslate;

            var translateTransformation = "translateY(" + translate + "em)";

            card.style.transform += rotationTransformation + " " + translateTransformation;

        }

      }

      _messyRotationForIndex(index) {

        var values = [-0.3, 0.8, -1.4, 1.2, -0.8, 1.5, -0.3, -1.2, -1.8, 0.7, -0.9, 0.9, 0.1, 1.8, 0.7, -0.5];

        index = index % values.length;

        return values[index];

      }

      _classes(layout) {
        var result = [];
        if (layout) {
          result.push(layout);
        }
        return result.join(" ");
      }

    }

    customElements.define(BoardgameCardCollection.is, BoardgameCardCollection);
  </script>
</dom-module>
