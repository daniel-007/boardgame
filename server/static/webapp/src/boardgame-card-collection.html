<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-flex-layout/iron-flex-layout.html">

<dom-module id="boardgame-card-collection">
  <template>
    <style>

      #container {
        position: relative;
        @apply --layout-horizontal;
        @apply --layout-wrap;
      }

      #container ::slotted(boardgame-card) {
        margin: 1em;
      }

      /* most cards in stacks should be at the front, and a few pixels down so
      /* you can see them behind the first few cards */

      .stack ::slotted(boardgame-card) {
        position: absolute;
        top: 6px;
        left: 0px;
      }

      /* the first child should actually take up layout space for the entire
      /* stack, and not be offset any. */

      .stack ::slotted(boardgame-card:first-child) {
        z-index: 10;
        position: relative;
        top:0px;
      }

      /* The second card should stick out justa bit */

      .stack ::slotted(boardgame-card:nth-child(2)) {
        top:2px;
        z-index: 9;
      }

      /* The third card should stick out just a bit more */

      .stack ::slotted(boardgame-card:nth-child(3)) {
        z-index: 8;
        top:2px;
      }

      .messy ::slotted(boardgame-card:nth-child(even)) {
        transform: rotate(-0.1deg);
      }

      .messy ::slotted(boardgame-card:nth-child(odd)) {
        transform: rotate(0.2deg);
      }

      .messy ::slotted(boardgame-card:nth-child(3n+0)) {
        transform: rotate(-0.5deg);
      }

      .messy ::slotted(boardgame-card:nth-child(3n+2)) {
        transform: rotate(0.7deg);
      }

      .messy ::slotted(boardgame-card:nth-child(4n+1)) {
        transform: rotate(2deg);
      }

    </style>

    <div id="container" class$="{{_classes(layout, messy)}}">
      <slot id="cards"></slot>
    </div>
  </template>

  <script>

    class BoardgameCardCollection extends Polymer.Element {

      static get is() {
        return "boardgame-card-collection"
      }

      static get properties() {
        return {
          layout: {
            type: String,
            observer: "_updateCardShadows"
          },
          messy: Boolean
        }
      }

      ready() {
        super.ready();
        this.$.cards.addEventListener("slotchange", () => this._updateCardShadows());
      }

      _updateCardShadows() {

        //Called when layout changes, or when items are added or removed from
        //the slot.

        //TODO: the fact that we do this imperatively (and trample on whatever
        //shadow setting was explicilty set by the element to start) seems
        //like a smell. However, doing this just with CSS was quite hard.


        var cards = this.$.cards.assignedNodes();

        var cardIndex = -1;

        for (var i = 0; i < cards.length; i++) {
          var card = cards[i];

          if (!card.localName || card.localName != "boardgame-card") {
            //Skip text nodes and nodes that aren't cards
            continue;
          }

          cardIndex++;

          if (this.layout != "stack") {
            card.noShadow = false;
            continue
          }

          if (cardIndex < 4) {
            card.noShadow = false;
          } else {
            card.noShadow = true;
          }

        }
      }

      _classes(layout, messy) {
        var result = [];
        if (layout) {
          result.push(layout);
        }
        if (messy) {
          result.push("messy");
        }
        return result.join(" ");
      }

    }

    customElements.define(BoardgameCardCollection.is, BoardgameCardCollection);
  </script>
</dom-module>
